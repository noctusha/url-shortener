package shortenerhandler

import (
	"bytes"
	"encoding/json"
	"fmt"
	"net/http"
	"net/http/httptest"
	"testing"

	"github.com/go-playground/validator/v10"
	"github.com/noctusha/url-shortener/internal/logger"
	short "github.com/noctusha/url-shortener/internal/service/shortener"
	"github.com/noctusha/url-shortener/internal/transport/http/shortenerhandler/mocks"
	"github.com/pkg/errors"
	"github.com/stretchr/testify/mock"
	"github.com/stretchr/testify/require"
)

func TestSaveHandler(t *testing.T) {
	type tc struct {
		name      string
		url       string
		alias     string
		respErr   string
		mockErr   error
		wantCode  int
		mockAlias string
	}

	tests := []tc{
		{
			name:      "Success",
			url:       "https://google.com",
			alias:     "google",
			mockErr:   nil,
			mockAlias: "google",
			respErr:   "",
			wantCode:  http.StatusOK,
		},
		{
			name:      "Success with autogenerated alias",
			url:       "https://example.com",
			alias:     "",
			mockErr:   nil,
			mockAlias: "RANDOMALIAS",
			respErr:   "",
			wantCode:  http.StatusOK,
		},
		{
			name:     "Empty url",
			url:      "",
			alias:    "something",
			wantCode: http.StatusUnprocessableEntity,
			respErr:  "field Url is a required field",
		},
		{
			name:     "Invalid URL",
			url:      "bulba",
			alias:    "kartoshka",
			wantCode: http.StatusUnprocessableEntity,
			respErr:  "field Url is not a valid URL",
		},
		{
			name:      "Alias duplicate",
			url:       "https://google.com",
			alias:     "google",
			mockErr:   short.ErrAliasAlreadyExists,
			wantCode:  http.StatusConflict,
			respErr:   "alias already exists",
			mockAlias: "",
		},
		{
			name:      "SaveURL internal error",
			url:       "https://yahoo.com",
			alias:     "test_alias",
			mockErr:   errors.New("failed to save url"),
			wantCode:  http.StatusInternalServerError,
			respErr:   "unexpected error",
			mockAlias: "",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			m := mocks.NewShortener(t)
			v := validator.New()
			h := New(logger.NewEmptyLogger(), v, m)

			shouldMockCall := tt.wantCode == http.StatusOK || tt.wantCode == http.StatusConflict || tt.wantCode == http.StatusInternalServerError

			if shouldMockCall {
				m.On("SaveURL",
					mock.Anything,
					tt.url,
					tt.alias,
				).Return(
					int32(1),
					tt.mockAlias,
					tt.mockErr,
				).Once()
			}

			body := fmt.Sprintf(`{"url": "%s", "alias": "%s"}`, tt.url, tt.alias)

			req, err := http.NewRequest(http.MethodPost, "/url", bytes.NewReader([]byte(body)))
			require.NoError(t, err)

			rr := httptest.NewRecorder()
			h.Save().ServeHTTP(rr, req)

			require.Equal(t, tt.wantCode, rr.Code)

			var resp SaveResponse
			require.NoError(t, json.Unmarshal(rr.Body.Bytes(), &resp))

			require.Equal(t, tt.respErr, resp.Error)

			if tt.alias == "" && tt.wantCode == http.StatusOK {
				require.NotEmpty(t, resp.Alias, "autogenerated alias must be returned")
			}

			if tt.wantCode == http.StatusOK && tt.alias != "" {
				require.Equal(t, tt.mockAlias, resp.Alias)
			}
		})
	}
}
