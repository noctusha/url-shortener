package shortenerhandler

import (
	"bytes"
	"encoding/json"
	"fmt"
	"net/http"
	"net/http/httptest"
	"testing"
	"time"

	"github.com/go-playground/validator/v10"
	"github.com/noctusha/url-shortener/internal/logger"
	short "github.com/noctusha/url-shortener/internal/service/shortener"
	"github.com/noctusha/url-shortener/internal/transport/http/shortenerhandler/mocks"
	"github.com/pkg/errors"
	"github.com/stretchr/testify/mock"
	"github.com/stretchr/testify/require"
)

func TestSaveHandler(t *testing.T) {
	type tc struct {
		name        string
		url         string
		alias       string
		mockErr     error
		mockAlias   string
		wantStatus  int
		wantRespErr string
	}

	tests := []tc{
		{
			name:        "Success",
			url:         "https://google.com",
			alias:       "google",
			mockErr:     nil,
			mockAlias:   "google",
			wantRespErr: "",
			wantStatus:  http.StatusOK,
		},
		{
			name:        "Success with autogenerated alias",
			url:         "https://example.com",
			alias:       "",
			mockErr:     nil,
			mockAlias:   "RANDOMALIAS",
			wantRespErr: "",
			wantStatus:  http.StatusOK,
		},
		{
			name:        "Empty url",
			url:         "",
			alias:       "something",
			wantStatus:  http.StatusUnprocessableEntity,
			wantRespErr: "field URL is a required field",
		},
		{
			name:        "Invalid URL",
			url:         "bulba",
			alias:       "kartoshka",
			wantStatus:  http.StatusUnprocessableEntity,
			wantRespErr: "field URL is not a valid URL",
		},
		{
			name:        "Alias duplicate",
			url:         "https://google.com",
			alias:       "google",
			mockErr:     short.ErrAliasAlreadyExists,
			wantStatus:  http.StatusConflict,
			wantRespErr: "alias already exists",
			mockAlias:   "",
		},
		{
			name:        "SaveURL internal error",
			url:         "https://yahoo.com",
			alias:       "test_alias",
			mockErr:     errors.New("failed to save url"),
			wantStatus:  http.StatusInternalServerError,
			wantRespErr: "internal error",
			mockAlias:   "",
		},
		{
			name:        "Invalid JSON",
			url:         `{"invalid": "json`,
			alias:       "",
			wantStatus:  http.StatusBadRequest,
			wantRespErr: "invalid JSON",
		},
		{
			name:        "ExpireAt in the past",
			url:         "https://example.com",
			alias:       "expired",
			wantStatus:  http.StatusUnprocessableEntity,
			wantRespErr: "expire_at must be in the future",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			m := mocks.NewShortener(t)
			v := validator.New()
			h := New(logger.NewEmptyLogger(), v, m)

			shouldMockCall := tt.wantStatus == http.StatusOK || tt.wantStatus == http.StatusConflict || tt.wantStatus == http.StatusInternalServerError

			if shouldMockCall {
				m.On("SaveURL",
					mock.Anything,
					tt.url,
					tt.alias,
					mock.Anything,
				).Return(
					int32(1),
					tt.mockAlias,
					tt.mockErr,
				).Once()
			}

			var body string
			switch tt.name {
			case "Invalid JSON":
				body = tt.url
			case "ExpireAt in the past":
				body = fmt.Sprintf(
					`{"url": "%s", "alias": "%s", "expire_at": "%s"}`,
					tt.url,
					tt.alias,
					time.Now().Add(-time.Hour).Format(time.RFC3339),
				)
			default:
				body = fmt.Sprintf(`{"url": "%s", "alias": "%s"}`, tt.url, tt.alias)
			}

			req, err := http.NewRequest(http.MethodPost, "/url", bytes.NewReader([]byte(body)))
			require.NoError(t, err)

			rr := httptest.NewRecorder()
			h.Save().ServeHTTP(rr, req)

			require.Equal(t, tt.wantStatus, rr.Code)

			var resp SaveResponse
			require.NoError(t, json.Unmarshal(rr.Body.Bytes(), &resp))

			require.Equal(t, tt.wantRespErr, resp.Error)

			if tt.wantStatus == http.StatusOK {
				require.Equal(t, "OK", resp.Status)
			} else {
				require.Equal(t, "Error", resp.Status)
			}

			if tt.alias == "" && tt.wantStatus == http.StatusOK {
				require.NotEmpty(t, tt.mockAlias, resp.Alias)
			}

			if tt.wantStatus == http.StatusOK && tt.alias != "" {
				require.Equal(t, tt.mockAlias, resp.Alias)
			}
		})
	}
}
