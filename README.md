# URL Shortener

URL Shortener — это HTTP-сервис для сокращения ссылок, реализованный на Go.
Проект спроектирован с упором на принципы Clean Architecture, явное разделение слоёв
(business logic, transport, storage), тестируемость и production-подходы
к разработке backend-сервисов.

---

## Возможности

- Создание коротких ссылок с пользовательским или автоматически сгенерированным алиасом
- Поддержка срока жизни ссылки (`expire_at`)
- HTTP API для управления ссылками (создание, удаление, редирект)
- Защищённые эндпоинты с использованием Basic Auth
- Ограничение частоты запросов (rate limiting) на основе Redis:
    - по IP-адресу
    - по комбинации IP + alias
- Наблюдаемость (observability):
    - метрики Prometheus
    - готовые дашборды Grafana
    - структурированное логирование с использованием slog и Loki
- CI-пайплайн:
    - автоматический запуск тестов
    - статический анализ кода
    - сборка Docker-образа

---

## Архитектура и стек

Проект построен с опорой на принципы Clean Architecture и явным разделением
ответственности между слоями. Бизнес-логика изолирована от деталей транспорта
и хранения данных, а зависимости направлены внутрь, к сервисному слою.

### Архитектура

- Transport layer (`internal/transport`)
    - HTTP API на базе `chi`
    - middleware для логирования, метрик и rate limiting
    - обработка HTTP-запросов и формирование ответов
    - зависит только от интерфейсов сервисного слоя

- Service layer (`internal/service`)
    - бизнес-логика сервиса
    - доменные ошибки и правила обработки ссылок
    - генерация алиасов
    - не зависит от HTTP, БД и фреймворков

- Storage layer (`internal/storage`)
    - реализация интерфейсов сервисного слоя
    - работа с PostgreSQL через `pgx` и `sqlc`
    - изоляция инфраструктурных деталей

- Observability (`internal/observability`)
    - метрики Prometheus
    - централизованная инициализация метрик

Такой подход упрощает тестирование, повышает гибкость системы и позволяет
изменять инфраструктурные детали без влияния на бизнес-логику.

### Стек технологий

- Go — основной язык разработки
- Chi — HTTP-роутер
- PostgreSQL — основное хранилище данных
- pgx / sqlc — типобезопасный доступ к базе данных
- Redis — rate limiting
- Prometheus — сбор метрик
- Grafana — визуализация метрик
- Loki + Promtail — сбор и агрегация логов
- Docker / Docker Compose — контейнеризация и локальный запуск
- GitHub Actions — CI (тесты, линтинг, сборка Docker-образа)

---

## HTTP API

Сервис предоставляет HTTP API для управления короткими ссылками.
Часть эндпоинтов защищена Basic Auth.


### Создание короткой ссылки

Метод: POST  
Путь: `/url`  
Требуется Basic Auth  
Content-Type: `application/json`

Тело запроса:

```json
{
  "url": "https://example.com",
  "alias": "example",
  "expire_at": "2025-12-31T23:59:59Z"
}
```

Описание полей:

- `url` — исходный URL (обязательное поле)
- `alias` — пользовательский алиас (опционально)
- `expire_at` — срок действия ссылки в формате RFC3339 (опционально)

Успешный ответ (200 OK):

```json
{
  "status": "OK",
  "alias": "example"
}
```

Возможные ошибки:

- 400 — некорректный JSON
- 401 — неавторизованный запрос
- 409 — алиас уже существует
- 422 — ошибка валидации входных данных
- 500 — внутренняя ошибка сервиса


### Редирект по короткой ссылке

Метод: GET  
Путь: `/{alias}`

Описание:

Выполняет HTTP-редирект на исходный URL.

Поведение:

- 302 — успешный редирект
- 404 — ссылка не найдена или срок действия истёк


### Удаление короткой ссылки

Метод: DELETE  
Путь: `/url/{alias}`  
Требуется Basic Auth

Успешный ответ (200 OK):

```json
{
  "status": "OK",
  "alias": "example"
}
```

Возможные ошибки:

- 400 — некорректный запрос
- 401 — неавторизованный запрос
- 404 — ссылка не найдена
- 500 — внутренняя ошибка сервиса

---

## Запуск проекта локально

Для локального запуска используется Docker Compose.
Проект можно запустить как напрямую через Docker Compose, так и с помощью Makefile.

### Требования

- Docker
- Docker Compose
- Make (опционально)

### Запуск

Рекомендуемый способ запуска:

```bash
make docker-up
```

Альтернативно, напрямую через Docker Compose:

```bash
docker-compose up -d --build
```

### Доступные сервисы

После запуска:

- HTTP API сервиса доступно по адресу: `http://localhost:8081`
- Эндпоинт метрик Prometheus: `http://localhost:8081/metrics`
- Prometheus доступен по адресу: `http://localhost:9090`
- Grafana доступна по адресу: `http://localhost:3000`

В Grafana автоматически загружаются готовые дашборды сервиса.

---

## Наблюдаемость (Observability)

В сервисе реализована базовая observability-настройка, ориентированная на
production-подходы.

Метрики:
- HTTP-метрики и метрики rate limiting
- Экспонируются в формате Prometheus
- Готовые дашборды Grafana загружаются автоматически

Логирование:
- Структурированные логи на базе `slog`
- Сбор логов через Promtail
- Хранение и просмотр логов в Loki

---

## CI / CD

В проекте настроен CI-пайплайн на базе GitHub Actions.

Пайплайн автоматически запускается при каждом коммите и включает:
- запуск unit-тестов
- статический анализ кода (`golangci-lint`)
- сборку Docker-образа сервиса

Docker-образ публикуется в GitHub Packages и может использоваться для
дальнейшего деплоя.

---

## Тестирование

Проект покрыт тестами на разных уровнях:
- unit-тесты бизнес-логики
- тесты HTTP-обработчиков
- интеграционные тесты для проверки полного сценария работы сервиса

Интеграционные тесты вынесены отдельно и не запускаются в CI по умолчанию,
что позволяет сохранять быстрый и стабильный пайплайн.
